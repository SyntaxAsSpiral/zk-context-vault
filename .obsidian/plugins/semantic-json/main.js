/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";var H=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var tt=Object.getOwnPropertyNames;var ot=Object.prototype.hasOwnProperty;var et=(t,o)=>{for(var n in o)H(t,n,{get:o[n],enumerable:!0})},nt=(t,o,n,i)=>{if(o&&typeof o=="object"||typeof o=="function")for(let l of tt(o))!ot.call(t,l)&&l!==n&&H(t,l,{get:()=>o[l],enumerable:!(i=Z(o,l))||i.enumerable});return t};var rt=t=>nt(H({},"__esModule",{value:!0}),t);var lt={};et(lt,{default:()=>W});module.exports=rt(lt);var F=require("obsidian");function m(t){return typeof t=="number"&&Number.isFinite(t)}function w(t){return typeof t=="string"?t.trim():typeof t=="number"||typeof t=="boolean"?String(t):""}function D(t){let o=t==null?void 0:t.type;return o==="text"&&typeof t.text=="string"?t.text.toLowerCase().trim():o==="file"&&typeof t.file=="string"?(t.file.split("/").pop()||t.file).toLowerCase().trim():o==="link"&&typeof t.url=="string"?t.url.toLowerCase().trim():o==="group"&&typeof t.label=="string"?t.label.toLowerCase().trim():w(t==null?void 0:t.id).toLowerCase()}function X(t){return(t==null?void 0:t.type)==="link"?1:0}function J(t){let o=t==null?void 0:t.color;return typeof o=="string"?o.toLowerCase():""}function U(t){let o=t==null?void 0:t.color;return typeof o=="string"?o.toLowerCase():""}function st(t){let o=t==null?void 0:t.fromEnd,n=t==null?void 0:t.toEnd;return o==="arrow"||n==="arrow"||n===void 0&&o!=="arrow"}function K(t,o,n){var f,d,S,N,x,I,u;let i=new Set(t.map(a=>w(a.id))),l=o.filter(a=>{let g=w(a==null?void 0:a.fromNode),h=w(a==null?void 0:a.toNode);return i.has(g)&&i.has(h)}),p=new Map,c=new Map,e=new Map;for(let a of t){let g=w(a.id);p.set(g,new Set),c.set(g,new Set),e.set(g,new Set)}for(let a of l){if(!st(a))continue;let g=w(a.fromNode),h=w(a.toNode);(f=p.get(g))==null||f.add(h),(d=p.get(h))==null||d.add(g);let C=a==null?void 0:a.fromEnd,A=(S=a==null?void 0:a.toEnd)!=null?S:"arrow";C==="arrow"&&A==="arrow"||(C==="arrow"?((N=c.get(h))==null||N.add(g),(x=e.get(g))==null||x.add(h)):((I=c.get(g))==null||I.add(h),(u=e.get(h))==null||u.add(g)))}let r=new Set,y=[];for(let[a]of p){if(r.has(a))continue;let g=new Set,h=[a];for(;h.length>0;){let C=h.shift();if(!r.has(C)){r.add(C),g.add(C);for(let A of p.get(C)||[])r.has(A)||h.push(A)}}g.size>1&&y.push(g)}let s=[];for(let a of y){let g=1/0,h=1/0;for(let E of a){let v=n.get(E),b=m(v==null?void 0:v.y)?v.y:0,M=m(v==null?void 0:v.x)?v.x:0;(b<g||b===g&&M<h)&&(g=b,h=M)}let C=new Map,A=new Map;for(let E of a){let v=0;for(let b of e.get(E)||[])a.has(b)&&v++;A.set(E,v)}let G=[];for(let E of a)A.get(E)===0&&(G.push(E),C.set(E,0));for(;G.length>0;){let E=G.shift(),v=C.get(E)||0;for(let b of c.get(E)||[]){if(!a.has(b))continue;let M=A.get(b)-1;A.set(b,M);let k=Math.max(C.get(b)||0,v+1);C.set(b,k),M===0&&G.push(b)}}for(let E of a)if(!C.has(E)){let v=Math.max(...Array.from(C.values()),0);C.set(E,v+1)}s.push({nodes:a,minY:g,minX:h,flowOrder:C})}return s}function Y(t,o,n,i,l){let p=[],c=new Map;if(o!=null&&o.flowSortNodes&&n&&i){p=K(t,n,i);for(let e of p)for(let r of e.nodes)c.set(r,e)}return t.sort((e,r)=>{let y=w(e==null?void 0:e.id),s=w(r==null?void 0:r.id);if(o!=null&&o.flowSortNodes){let u=c.get(y),a=c.get(s);if(u&&a)if(u===a){let g=u.flowOrder.get(y)||0,h=a.flowOrder.get(s)||0;if(g!==h)return g-h;let C=m(e==null?void 0:e.y)?e.y:0,A=m(r==null?void 0:r.y)?r.y:0;if(C!==A)return C-A;let G=m(e==null?void 0:e.x)?e.x:0,E=m(r==null?void 0:r.x)?r.x:0;if(G!==E)return G-E;if((o==null?void 0:o.colorSortNodes)!==!1){let v=J(e),b=J(r);if(v!==b)return v.localeCompare(b)}return D(e).localeCompare(D(r))}else{if(u.minY!==a.minY)return u.minY-a.minY;if(u.minX!==a.minX)return u.minX-a.minX}else if(u&&!a){let g=m(r==null?void 0:r.y)?r.y:0,h=m(r==null?void 0:r.x)?r.x:0;return u.minY!==g?u.minY-g:u.minX!==h?u.minX-h:-1}else if(!u&&a){let g=m(e==null?void 0:e.y)?e.y:0,h=m(e==null?void 0:e.x)?e.x:0;return g!==a.minY?g-a.minY:h!==a.minX?h-a.minX:1}}if(l){let u=X(e),a=X(r);if(u!==a)return u-a;if((o==null?void 0:o.colorSortNodes)!==!1){let g=J(e),h=J(r);if(g!==h)return g.localeCompare(h)}return D(e).localeCompare(D(r))}let f=m(e==null?void 0:e.y)?e.y:0,d=m(r==null?void 0:r.y)?r.y:0;if(f!==d)return f-d;let S=m(e==null?void 0:e.x)?e.x:0,N=m(r==null?void 0:r.x)?r.x:0;if(S!==N)return S-N;let x=X(e),I=X(r);if(x!==I)return x-I;if((o==null?void 0:o.colorSortNodes)!==!1){let u=J(e),a=J(r);if(u!==a)return u.localeCompare(a)}return D(e).localeCompare(D(r))}),t}function it(t,o,n,i){let l=new Map;if(n!=null&&n.flowSortNodes&&i){let p=K(i,t,o);for(let c of p)for(let e of c.nodes)l.set(e,c)}return t.sort((p,c)=>{var v,b,M,k;let e=w(p==null?void 0:p.fromNode),r=w(c==null?void 0:c.fromNode),y=w(p==null?void 0:p.toNode),s=w(c==null?void 0:c.toNode);if(n!=null&&n.flowSortNodes&&l.size>0){let T=l.get(e),$=l.get(r);if(T&&$){let P=(v=T.flowOrder.get(e))!=null?v:1/0,L=(b=$.flowOrder.get(r))!=null?b:1/0;if(P!==L)return P-L}let B=l.get(y),q=l.get(s);if(B&&q){let P=(M=B.flowOrder.get(y))!=null?M:1/0,L=(k=q.flowOrder.get(s))!=null?k:1/0;if(P!==L)return P-L}}let f=o.get(e),d=o.get(r),S=m(f==null?void 0:f.y)?f.y:0,N=m(d==null?void 0:d.y)?d.y:0;if(S!==N)return S-N;let x=m(f==null?void 0:f.x)?f.x:0,I=m(d==null?void 0:d.x)?d.x:0;if(x!==I)return x-I;let u=o.get(y),a=o.get(s),g=m(u==null?void 0:u.y)?u.y:0,h=m(a==null?void 0:a.y)?a.y:0;if(g!==h)return g-h;let C=m(u==null?void 0:u.x)?u.x:0,A=m(a==null?void 0:a.x)?a.x:0;if(C!==A)return C-A;if((n==null?void 0:n.colorSortEdges)!==!1){let T=U(p),$=U(c);if(T!==$)return T.localeCompare($)}let G=w(p==null?void 0:p.id),E=w(c==null?void 0:c.id);return G.localeCompare(E)}),t}function z({input:t,settings:o}){let n=Array.isArray(t==null?void 0:t.nodes)?[...t.nodes]:[],i=Array.isArray(t==null?void 0:t.edges)?[...t.edges]:[],l=new Set,p=new Map;for(let s of n){let f=w(s==null?void 0:s.id);if(!f)throw new Error("node missing id");if(l.has(f))throw new Error(`duplicate node id: ${f}`);l.add(f),p.set(f,{x:s==null?void 0:s.x,y:s==null?void 0:s.y})}let c=new Set;for(let s of i){let f=w(s==null?void 0:s.id);if(!f)throw new Error("edge missing id");if(c.has(f))throw new Error(`duplicate edge id: ${f}`);c.add(f);let d=w(s==null?void 0:s.fromNode),S=w(s==null?void 0:s.toNode);if(!d||!S)throw new Error(`edge ${f} missing fromNode/toNode`);if(!l.has(d))throw new Error(`edge ${f} references missing fromNode: ${d}`);if(!l.has(S))throw new Error(`edge ${f} references missing toNode: ${S}`)}let e=at(n),r=ct(n,e,o,i,p),y=[...i];return it(y,p,o,n),{nodes:r,edges:y}}function Q(t,o){let n=Array.isArray(t==null?void 0:t.edges)?t.edges:[],i=n.filter(s=>"label"in s&&s.label!==void 0),l=n.filter(s=>!("label"in s)||s.label===void 0),p=new Map,c=new Map;for(let s of i){let f=w(s.fromNode),d=w(s.toNode);c.has(f)||c.set(f,[]),c.get(f).push({node:d,label:s.label}),p.has(d)||p.set(d,[]),p.get(d).push({node:f,label:s.label})}let e=Array.isArray(t==null?void 0:t.nodes)?t.nodes.map(s=>{let f={id:s.id,type:s.type};"text"in s&&s.text!==void 0&&(f.text=s.text),"file"in s&&s.file!==void 0&&(f.file=s.file),"url"in s&&s.url!==void 0&&(f.url=s.url),"label"in s&&s.label!==void 0&&(f.label=s.label);let d=w(s.id);return p.has(d)&&(f.from=p.get(d)),c.has(d)&&(f.to=c.get(d)),f}):[],y=(o==null?void 0:o.flowSortNodes)||(o==null?void 0:o.stripEdgesWhenFlowSorted)?[]:l.map(s=>({id:s.id,fromNode:s.fromNode,toNode:s.toNode}));return{nodes:e,edges:y}}function R(t){let o=[],n=0,i=()=>`imported-${(n++).toString(16).padStart(16,"0")}`;function l(c,e,r){let y=i(),s=r.x,f=r.y;if(c==null){let d=e!==null?`${String(e)}: null`:"null";o.push({id:y,type:"text",text:d,x:s,y:f,width:250,height:60}),r.y+=80}else if(typeof c=="object"&&!Array.isArray(c)){let d=e!==null?String(e):"root",S=y,N={x:s+20,y:f+80},x=Object.entries(c);for(let[u,a]of x)l(a,u,N);let I=Math.max(N.y-f+20,100);o.push({id:S,type:"group",label:d,x:s,y:f,width:600,height:I}),r.y=N.y}else if(Array.isArray(c)){let d=e!==null?String(e):"array",S=y,N={x:s+20,y:f+80};for(let I=0;I<c.length;I++)l(c[I],I,N);let x=Math.max(N.y-f+20,100);o.push({id:S,type:"group",label:d,x:s,y:f,width:600,height:x}),r.y=N.y}else{let d=typeof c=="string"?c:JSON.stringify(c),S=e!==null?`${String(e)}: ${d}`:d;o.push({id:y,type:"text",text:S,x:s,y:f,width:250,height:60}),r.y+=80}}return l(t,null,{x:0,y:0}),{nodes:o,edges:[]}}function _(t,o){let n=m(t==null?void 0:t.x)?t.x:0,i=m(t==null?void 0:t.y)?t.y:0,l=m(t==null?void 0:t.width)?t.width:0,p=m(t==null?void 0:t.height)?t.height:0,c=m(o==null?void 0:o.x)?o.x:0,e=m(o==null?void 0:o.y)?o.y:0,r=m(o==null?void 0:o.width)?o.width:0,y=m(o==null?void 0:o.height)?o.height:0;return n>=c&&i>=e&&n+l<=c+r&&i+p<=e+y}function at(t){let o=t.filter(l=>(l==null?void 0:l.type)==="group"),n=t.filter(l=>(l==null?void 0:l.type)!=="group"),i=new Map;for(let l of n){let p=null,c=1/0;for(let e of o)if(_(l,e)){let r=(e.width||0)*(e.height||0);r<c&&(c=r,p=e)}if(p){let e=w(p.id);i.has(e)||i.set(e,[]),i.get(e).push(l)}}for(let l of o){let p=null,c=1/0;for(let e of o)if(l.id!==e.id&&_(l,e)){let r=(e.width||0)*(e.height||0);r<c&&(c=r,p=e)}if(p){let e=w(p.id);i.has(e)||i.set(e,[]),i.get(e).push(l)}}return i}function ct(t,o,n,i,l){let p=t.filter(d=>(d==null?void 0:d.type)==="group"),c=t.filter(d=>(d==null?void 0:d.type)!=="group"),e=[],r=new Set;function y(d){let S=w(d.id);if(!r.has(S)&&(r.add(S),e.push(d),d.type==="group"&&o.has(S))){let N=o.get(S);Y(N,n,i,l,!0);let x=N.filter(u=>(u==null?void 0:u.type)==="group"),I=N.filter(u=>(u==null?void 0:u.type)!=="group");Y(x,{...n,colorSortNodes:!1},i,l,!1);for(let u of I)y(u);for(let u of x)y(u)}}let s=c.filter(d=>{let S=w(d.id);for(let[,N]of o.entries())if(N.some(x=>w(x.id)===S))return!1;return!0}),f=p.filter(d=>{let S=w(d.id);for(let[,N]of o.entries())if(N.some(x=>w(x.id)===S))return!1;return!0});Y(s,n,i,l,n==null?void 0:n.semanticSortOrphans),Y(f,n,i,l);for(let d of s)y(d);for(let d of f)y(d);return e}var O=require("obsidian"),V={autoCompile:!0,colorSortNodes:!0,colorSortEdges:!0,flowSortNodes:!1,semanticSortOrphans:!1,stripEdgesWhenFlowSorted:!0},j=class extends O.PluginSettingTab{constructor(o,n){super(o,n),this.plugin=n}display(){let{containerEl:o}=this;o.empty(),new O.Setting(o).setName("Compilation").setHeading(),new O.Setting(o).setName("Auto-compile on save").setDesc("Automatically compile canvas to semantic JSON when saving .canvas files.").addToggle(n=>n.setValue(this.plugin.settings.autoCompile).onChange(async i=>{this.plugin.settings.autoCompile=i,await this.plugin.saveSettings()})),new O.Setting(o).setName("Sorting").setHeading(),new O.Setting(o).setName("Color sort nodes").setDesc("Group nodes by color within the same spatial position. Preserves visual taxonomy (e.g., red = urgent, blue = reference).").addToggle(n=>n.setValue(this.plugin.settings.colorSortNodes).onChange(async i=>{this.plugin.settings.colorSortNodes=i,await this.plugin.saveSettings()})),new O.Setting(o).setName("Color sort edges").setDesc("Group edges by color within the same topology. Preserves visual flow semantics.").addToggle(n=>n.setValue(this.plugin.settings.colorSortEdges).onChange(async i=>{this.plugin.settings.colorSortEdges=i,await this.plugin.saveSettings()})),new O.Setting(o).setName("Flow sort nodes").setDesc("Group nodes by directional flow order. Nodes connected by arrows form conceptual groups that sort by flow topology rather than strict spatial position.").addToggle(n=>n.setValue(this.plugin.settings.flowSortNodes).onChange(async i=>{this.plugin.settings.flowSortNodes=i,await this.plugin.saveSettings()})),new O.Setting(o).setName("Group orphan nodes").setDesc("Group orphan nodes first before sorting spatially. Orphan nodes are nodes that are not connected to any other nodes by groups or edges, and will be sorted to the top as a single group.").addToggle(n=>n.setValue(this.plugin.settings.semanticSortOrphans).onChange(async i=>{this.plugin.settings.semanticSortOrphans=i,await this.plugin.saveSettings()})),new O.Setting(o).setName("Export").setHeading(),new O.Setting(o).setName("Strip edges from pure JSON when flow-sorted").setDesc("Flow topology is compiled into node sequence order. Edges become redundant and can be safely removed from pure JSON exports.").addToggle(n=>n.setValue(this.plugin.settings.stripEdgesWhenFlowSorted).onChange(async i=>{this.plugin.settings.stripEdgesWhenFlowSorted=i,await this.plugin.saveSettings()}))}};var W=class extends F.Plugin{constructor(){super(...arguments);this.settings={...V};this.isCompiling=!1}async onload(){await this.loadSettings(),this.addSettingTab(new j(this.app,this)),this.addCommand({id:"compile-active-canvas",name:"Compile active canvas",callback:()=>void this.compileActive()}),this.addCommand({id:"export-as-pure-json",name:"Export as pure JSON",callback:()=>void this.exportAsPureJson()}),this.addCommand({id:"import-json-to-canvas",name:"Import JSON to canvas",callback:()=>void this.importJsonToCanvas()}),this.registerEvent(this.app.vault.on("modify",n=>{this.settings.autoCompile&&(!(n instanceof F.TFile)||n.extension!=="canvas"||this.compileFile(n,!1))}))}async loadSettings(){this.settings=Object.assign({},V,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async compileActive(){let n=this.app.workspace.getActiveFile();if(!n||n.extension!=="canvas"){new F.Notice("No active canvas file");return}await this.compileFile(n,!0)}async exportAsPureJson(){let n=this.app.workspace.getActiveFile();if(!n||n.extension!=="canvas"){new F.Notice("No active canvas file");return}try{let i=await this.app.vault.read(n),l=JSON.parse(i),p=z({input:l,settings:{colorSortNodes:this.settings.colorSortNodes,colorSortEdges:this.settings.colorSortEdges,flowSortNodes:this.settings.flowSortNodes,semanticSortOrphans:this.settings.semanticSortOrphans}}),c=Q(p,{flowSortNodes:this.settings.flowSortNodes,stripEdgesWhenFlowSorted:this.settings.stripEdgesWhenFlowSorted}),e=JSON.stringify(c,null,2)+`
`,r=n.path.replace(/\.canvas$/,".pure.json"),y=this.app.vault.getAbstractFileByPath(r);y instanceof F.TFile?await this.app.vault.modify(y,e):await this.app.vault.create(r,e),new F.Notice(`Exported to ${r}`)}catch(i){console.error(i),new F.Notice(`Export failed${i instanceof Error?`: ${i.message}`:""}`)}}async importJsonToCanvas(){let n=this.app.workspace.getActiveFile();if(!n||n.extension!=="json"){new F.Notice("No active JSON file");return}try{let i=await this.app.vault.read(n),l=JSON.parse(i),p=R(l),c=JSON.stringify(p,null,2)+`
`,e=n.path.replace(/\.json$/,".canvas"),r=this.app.vault.getAbstractFileByPath(e);r instanceof F.TFile?await this.app.vault.modify(r,c):await this.app.vault.create(e,c),new F.Notice(`Imported to ${e}`)}catch(i){console.error(i),new F.Notice(`Import failed${i instanceof Error?`: ${i.message}`:""}`)}}async compileFile(n,i){if(!this.isCompiling){this.isCompiling=!0;try{let l=await this.app.vault.read(n),p=JSON.parse(l),c=z({input:p,settings:{colorSortNodes:this.settings.colorSortNodes,colorSortEdges:this.settings.colorSortEdges,flowSortNodes:this.settings.flowSortNodes,semanticSortOrphans:this.settings.semanticSortOrphans}}),e=JSON.stringify(c,null,2)+`
`;if(e===l){i&&new F.Notice("Canvas already compiled");return}await this.app.vault.modify(n,e),i&&new F.Notice("Canvas compiled")}catch(l){console.error(l),i&&new F.Notice(`Canvas compilation failed${l instanceof Error?`: ${l.message}`:""}`)}finally{this.isCompiling=!1}}}};
